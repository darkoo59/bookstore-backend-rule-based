package rules;

import com.example.bookstorebackend.book.Book;
import com.example.bookstorebackend.person.model.Author
import com.example.bookstorebackend.rating.model.Rating;
import com.example.bookstorebackend.genre.Genre;
import com.example.bookstorebackend.genre.Genre;
import com.example.bookstorebackend.order.model.Order;
import com.example.bookstorebackend.orderItem.OrderItem;
import java.util.List;
import java.util.stream.Collectors
import java.util.Comparator
import java.util.ArrayList
import java.util.Collections;
import com.example.bookstorebackend.person.model.User
import com.example.bookstorebackend.person.model.Person
import com.example.bookstorebackend.book.BookCharacteristics
import java.util.Set
import java.util.HashSet
import java.util.Map
import java.util.TreeMap
import java.util.stream.Stream
import java.util.LinkedHashMap
import java.time.LocalDate;
import com.example.bookstorebackend.book.BookForRecommendation;

global java.util.ArrayList recommendedBooks;
global com.example.bookstorebackend.person.model.User specificUser;
global java.util.concurrent.ConcurrentHashMap<Book,Integer> recommendedBooksWithScores;

rule "Remove Authors Without Books"
salience 50
no-loop true
when
    $author: Author(getBookNumber() == 0)
then
    delete($author);
end

rule "Determine Author Genres"
lock-on-active
salience 45
when
    $author: Author()
    $genres: List(size > 0) from collect(Genre())
then
    boolean valid = false;
    for(Object genre: $genres){
        int count = $author.getBookNumberFromGenre((Genre)genre);
        if((count * 1.0 / $author.getBooks().size()) > 0.3){
            valid = true;
        }
    }
    if(valid){
        modify($author){setCorrectGenre(valid)}
    }
end

rule "Collect All Authors"
salience 40
no-loop true
when
    $authors: List(size > 0) from collect(Author(isCorrectGenre() == true))
then
    List<Author> authors = new ArrayList<>($authors);
    authors.sort(Comparator.comparingDouble(a -> ((Author)a).getTotalRatingNumber()).reversed());
    List<Author> sublist = authors.subList(0, Math.min(authors.size(), 4));
    for(Object c: $authors){
        delete(c);
    }
    for(Author author: sublist){
        author.setPopular(true);
        insert(author);
    }
end

rule "Insert Books From Popular Authors"
salience 35
no-loop true
when
  $author: Author(isPopular() == true)
then
    for(Book book: $author.getBooks()) {
        insert(book);
    }
end

rule "Select Top 10 Books"
salience 30
no-loop true
when
  $books: List(size > 0) from collect(Book())
  $user: User(id == specificUser.getId() && getRatingsNumber() < 10)
then
    System.out.println("Rule [Select Top 10 Books] - fired");
    List<Book> sortedBooks = new ArrayList<>($books);
    sortedBooks.sort(Comparator.comparingDouble(a -> ((Book)a).getTotalRatingNumber()).reversed());
    List<Book> top10Books = sortedBooks.subList(0, Math.min(sortedBooks.size(), 10));
    recommendedBooks.addAll(top10Books);
end

rule "Users similarity based on Pearson correlation coefficient"
salience 25
no-loop true
when
    $user: User(id == specificUser.getId() && getRatingsNumber() >= 10)
    $user2: User(id != specificUser.getId())
    $books: List(size > 0) from collect(Book())
then
        System.out.println("Rule [Users similarity based on Pearson correlation coefficient] - fired");
        double similarity = $user.calculateSimilarity($user2);
        if (similarity >= 0.5) {
            List<String> booksLikedBySimilarUser = $user2.getRatings().stream()
                .filter(rating -> rating.getRating() >= 4.0)
                .map(rating -> rating.getBook().getId().toString())
                .collect(Collectors.toList());
            List<Book> allBooks = new ArrayList<>($books);
            List<Book> booksLikedByUser = new ArrayList<>();
            for (String bookId : booksLikedBySimilarUser) {
                for(Book book : allBooks){
                    if(book.getId() == Long.parseLong(bookId)){
                        booksLikedByUser.add(book);
                        if (recommendedBooksWithScores.containsKey(book)) {
                            // Book already exists, increment the score by 1
                            Integer score = (Integer)recommendedBooksWithScores.get(book);
                            recommendedBooksWithScores.put(book, score + 1);
                        } else {
                            // Book doesn't exist, add it with a score of 1
                            recommendedBooksWithScores.put(book, 1);
                        }
                    }
                }
                }
            recommendedBooks.addAll(booksLikedByUser);
        }
end

rule "Add points to books that are similar to books that user likes"
salience 20
when
    $user: User(id == specificUser.getId() && getRatingsNumber() >= 10)
    $otherUser: User(id != specificUser.getId())
    $thisBook: Book(id != 0)
    $books: List() from $user.getBooksThatUserLikes()
then
    List<BookForRecommendation> booksList = new ArrayList<>();
    for (var otherBook: $books) {
        if ($thisBook.areBooksSimilar((Book)otherBook)) {
            booksList.add(new BookForRecommendation((Book)otherBook, 1));
        }
    }
end

rule "Recommend books based on user preferences"
salience 15
no-loop true
when
    $user: User(id == specificUser.getId() && getRatingsNumber() >= 10)
    $authors: List(size > 0) from collect(Author())
    $genres: List(size > 0) from collect(Genre())
    $books: List(size > 0) from collect(Book())
then
    System.out.println("Rule [Recommend books based on user preferences] - fired");
    // Apply book recommendations based on user preferences
    List<Author> allAuthors = new ArrayList<>($authors);
    List<Genre> allGenres = new ArrayList<>($genres);
    List<Book> recommendedBooksByAuthor = new ArrayList<>();
    List<Order> userOrders = $user.getOrders();
    for(Author author : allAuthors){
        int numOfAuthorBuys = 0;
        for (Order order : userOrders) {
            if(order.isOrderInLastSixMonths()){
                for(OrderItem orderItem : order.getOrderItems()){
                    if(orderItem.getBook().getAuthor().getId().equals(author.getId()))
                        numOfAuthorBuys++;
                }
            }
        }
        if(numOfAuthorBuys >= 3){
            for(Book bookIter: author.getBooks()){
                if (recommendedBooksWithScores.containsKey(bookIter)) {
                    // Book already exists, increment the score by 1
                    Integer score = (Integer)recommendedBooksWithScores.get(bookIter);
                    recommendedBooksWithScores.put(bookIter, score + 1);
                } else {
                    // Book doesn't exist, add it with a score of 1
                    recommendedBooksWithScores.put(bookIter, 1);
                }
            }
            recommendedBooks.addAll(author.getBooks());
        }
    }
    List<Genre> genresToRecommend = new ArrayList<>();
    for(Genre genre: allGenres) {
        int numOfGenreBuys = 0;
        int numOfBooksBuys = 0;
        for (Order orderIter : userOrders) {
            if(orderIter.isOrderInLastSixMonths()){
                for(OrderItem orderItemIter : orderIter.getOrderItems()){
                    numOfBooksBuys++;
                    if(orderItemIter.getBook().getGenre().getId().equals(genre.getId()))
                        numOfGenreBuys++;
                }
            }
        }
        if((double)numOfGenreBuys/numOfBooksBuys >= 0.3){
            genresToRecommend.add(genre);
        }
    }
    List<Book> allBooks = new ArrayList<>($books);
    for(Book book: allBooks){
        if(genresToRecommend.contains(book.getGenre())){
            recommendedBooks.add(book);
            if (recommendedBooksWithScores.containsKey(book)) {
                // Book already exists, increment the score by 1
                Integer scoreTemp = (Integer)recommendedBooksWithScores.get(book);
                recommendedBooksWithScores.put(book, scoreTemp + 1);
            } else {
                // Book doesn't exist, add it with a score of 1
                recommendedBooksWithScores.put(book, 1);
            }
            }
    }
    Set<Book> setWithoutDuplicates = new HashSet<>(recommendedBooks);
    recommendedBooks = new ArrayList<>(setWithoutDuplicates);
end

rule "Final recommendation"
salience 10
no-loop true
when
      $user: User(id == specificUser.getId() && getRatingsNumber() >= 10)
then
      System.out.println("Rule [Final recommendation] - fired");
      List<Map.Entry<Book, Integer>> list = new ArrayList<>(recommendedBooksWithScores.entrySet());
      list.sort(Map.Entry.comparingByValue());
      Map<Book, Integer> sortedMap = new LinkedHashMap<>();
      for (Map.Entry<Book, Integer> entry : list) {
          sortedMap.put(entry.getKey(), entry.getValue());
      }
      recommendedBooks = new ArrayList(sortedMap.entrySet().stream().map(Map.Entry::getKey).toList());
      List<Book> afterTopTwenty = sortedMap.entrySet().stream()
              .sorted((e1, e2) -> {
                  int scoreComparison = e2.getValue().compareTo(e1.getValue()); // Sort by score in descending order

                  if (scoreComparison == 0) {
                      LocalDate date1 = e1.getKey().getDateOfAddingToBookstore();
                      LocalDate date2 = e2.getKey().getDateOfAddingToBookstore();
                      return date2.compareTo(date1); // Sort by date of adding to bookstore in descending order
                  }
                  return scoreComparison;
              })
              .limit(20)
              .map(Map.Entry::getKey)
              .toList();
      recommendedBooks = new ArrayList(afterTopTwenty);
end